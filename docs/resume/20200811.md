## 记一次面试 （20200811）

### v-if 和 v-show 的区别

`v-if` 是“真实的”条件渲染，因为它可以确保条件块内的事件侦听器和子组件在触发期间正确销毁并重新创建。

`v-show` 是基于CSS的切换，无论初始条件如何，始终呈现元素。`v-show` 不支持 `<template>` 元素，也不配合使用 `v-else`。

### v-if 和 v-for

当它们存在于同一级节点上时，`v-for` 具有比更高的优先级 `v-if`。这意味着 `v-if` 将在循环的每次迭代中分别运行。当你只想为某些项目渲染阶段时，这将非常有用，如下所示：

```vue
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo }}
</li>
```

上面仅渲染了不完整的待办事项。

### vue-router 有哪几种导航钩子

三种

第一种，全局导航守卫  

- 全局前置守卫

```js
router.beforeEach((to, from, next) => {
  // start progress bar
  NProgress.start()
  next()
})
```

- 全局解析守卫

```js
router.beforeResolve((to, from, next) => {
  // 根据单页面路径的指向不同，访问的接口域名也不同
  let url
  if(to.path === 'a') {
    url = 'https://www.a.com'
  } else if(to.path === 'b') {
    url = 'https://www.b.com'
  }
  store.dispatch('app/updateAppBaseApi', url)
  next()
})
```

- 全局后置守卫

```js
router.afterEach((to, from) => {
  // done progress bar
  NProgress.done()
})
```

    
第二种，路由独享的守卫

```js
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```


第三种，组件内的守卫
- `beforeRouterEnter`
- `beforeRouterUpdate`
- `beforeRouterLeave`

```js
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
```

### 水平垂直居中CSS

第一种，缺点是需要知道子元素的宽高

 ```css
  .wrapper {
    position: relative;
    width: 300px;
    height: 300px;
    border: 1px solid #000;
  }

  .box {
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;

    width: 100px;
    height: 100px;
    background-color: red;
  }
```

第二种，还是绝对定位，但这个方法不需要子元素固定宽高

```css
  .wrapper {
    position: relative;
    width: 300px;
    height: 300px;
    border: 1px solid #000;
  }

  .box {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);

    width: 100px;
    height: 100px;
    background-color: red;
  }
```

第三种，flex布局

```css
  .wrapper {
    display: flex;
    align-items: center;
    justify-content: center;

    width: 300px;
    height: 300px;
    border: 1px solid #000;
  }

  .box {
    width: 100px;
    height: 100px;
    background-color: red;
  }
```